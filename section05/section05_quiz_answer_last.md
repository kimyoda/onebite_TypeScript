# TypeScript section05 Ai 퀴즈, 해설정리

## 1. 인터페이스가 타입 별칭과 비교했을 때, 객체 타입을 정의할 때 제공하는 특별한 기능은?

- A) 유니언 또는 인터섹션 타입 직접 정의
- B) 선택적(Optional) 속성 정의
- C) 상속(확장) 및 선언 병합 기능 ✅
- D) 읽기 전용(Readonly) 속성 정의

**해설**

- 인터페이스는 객체 타입 정의에 특화되어 있다.
- 타입 별칭과는 다르게 **확장(extends)**으로 속성을 물려받을 수 있고, 동일 이름으로 여러 번 선언해도 **선언 병합**으로 자동 결합된다.

**추가 설명**

- `type`도 객체 타입을 만들 수 있으나, **같은 이름으로 중복 선언하면 보통 충돌/에러**가 난다.
- interface는 설계상 점진적으로 타입을 키우는 사용이 가능하여, **외부 라이브러리 타입 보강** 같은 패턴에 활용할 수 있다.

- A): `type`이 특히 강하다. type A = X | Y처럼 type이 더 일반적이다.
- B): 선택적(Optional) 속성 정의, `type`도 선택적 속성으로 만들 수 있다.

```ts
interface Base {
  id: string;
}
interface User extends Base {
  name: string;
} // 확장(상속)

interface User {
  age: number;
} // 선언 병합(동일 이름 확장)
const u: User = { id: "1", name: "kim", age: 20 };
```

---

## 2. 인터페이스에서 동일한 이름의 메소드를 여러 개 정의(메소드 오버로딩)하려면 어떤 방식?

- A) 함수 타입 표현식

- B) 호출 시그니처 ✅

- C) 화살표 함수 문법

- D) 제네릭 타입

**해설**

- 인터페이스는 호출 시그니쳐 형태로 메소드 시그니쳐를 여러 개 선언해 오버로딩을 표현한다.

**추가 설명**

- 구현을 여러 개 만드는 것이 아닌, 호출 가능한 형태를 여러 개 타입으로 선언하는 개념이다.
- 실제 구현은 하나고, 오버로드 시그니쳐들이 구현을 타입으로 감싸는 역할을 한다.

1. 함수표현식

- `(a: number) => string`처럼 **함수 자체의 타입(시그니쳐)**를 표현하는 문법이다.
- 호출 가능 형태를 한줄로 정의하는데 좋다.

2. 화살표 함수 타입

- `() => {}` 같은 **런타임(값) 문법**으로 실제 함수를 구현할 때 쓰는 문법이다.

3. 제네릭 타입

- 타입/함수에 **타입 파라미터(T)**를 도입해 여러 타입에 대해 재사용 가능하게 만드는 기능이다.
- 하나의 시그니쳐로 다양한 타입을 포괄하려는 목적에 더 적합하다.

```ts
interface Api {
  request(url: string): string;
  request(url: string, retry: number): string;
}
```

- 문법 설명

---

## 3. 인터페이스 확장(상속)을 사용하는 주된 이점은?

- A) 속성 타입을 자유롭게 다른 타입으로 재정의 가능

- B) 동일 이름 선언 시 속성이 자동으로 합쳐짐

- C) 타입 정의 시 속성 중복을 최소화 ✅

- D) 객체 타입 외 다른 타입 정의 가능

**해설**

- 인터페이스 확장은 다른 인터페이스의 속성을 물려받아 새로운 인터페이스를 정의할 수 있게 해준다.
- 여러 관련 타입에서 공통된 속성을 반복해서 정의할 필요가 없다.

**추가설명**

- 공통 속성을 상위 인터페이스로 빼고, 하위 타입들이 일관된 형태를 가지게된다.
- 도메인이 클수록 (User/Admin/Guest 등) 확장은 타입 중복 제거 + 유지보수성에 도움이 된다.

```ts
interface Entity {
  id: string;
  createdAt: Date;
}
interface Post extends Entity {
  title: string;
}
interface Comment extends Entity {
  content: string;
}
```

---

## 4. 함동일한 이름으로 인터페이스를 여러 번 선언하면 어떻게 될까요?

- A) 오류가 발생합니다.

- B) 가장 마지막 선언만 유효합니다.

- C) 모든 선언의 속성이 합쳐져 하나의 인터페이스가 됩니다. ✅

- D) 가장 첫 선언만 유효하고 나머지는 무시됩니다.

**해설**

- 타입 별칭과 달리 인터페이스는 동일 이름으로 여러 번 선언해도 오류 없이 정의된 속성들이 모두 합쳐 하나의 타입처럼 동작한다.
- 이 특징을 **선언 병합(Declaration Merging)**이라 한다.

**추가설명**

- 병합은 자동합치기고 의도치 않게 타입이 커질 위험도 있다.

```ts
interface Config {
  debug: boolean;
}
interface Config {
  timeout: number;
}

const c: Config = { debug: true, timeout: 1000 };
```

---

## 5. 인터페이스 선언 병합이 일반적으로 활용되는 고급 시나리오는?

- A) 객체 속성을 선택적으로 만들기

- B) 라이브러리 등 외부 모듈의 타입 정의 보강 ✅

- C) 다양한 원시 타입의 조합 정의

- D) 클래스의 생성자 함수 타입 정의

**해설**

- **선언 병합**은 이미 정의된 타입(라이브러리 타입)에 새로운 속성이나 메소드를 추가하여 타입 정의를 확장할 때 유용하게 사용된다
- 이를 **모듈 보강(Module Augmentation)**라 한다.

**추가 설명**

- 외부 라이브러리 타입 정의가 프로젝트 요구를 못담을 때 보강한다.
- 전역 객체/환경 타입에 프로젝트 전용 속성 추가, 라이브러리 옵션 타입에 커스텀 필드를 추가하는 등.

```ts
// 예시 형태(개념용): 기존 라이브러리 타입에 속성 추가
declare global {
  interface Window {
    myAppVersion: string;
  }
}
```
