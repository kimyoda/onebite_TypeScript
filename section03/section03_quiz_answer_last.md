# TypeScript Ai 퀴즈, 해설정리

## 1. TypeScript에서 문법만 알아서는 부족한 이유는?

- A) 코드 실행 속도가 느려져서
- B) 새로운 문제를 만나면 해결하기 어려워서 ✅
- C) 문법 규칙이 자주 바뀌기 때문에
- D) 타입을 전혀 사용할 수 없게 되어서

**해설**

- 문법만 외우면 낯선 상황에서 문제 해결이 어렵다는 점. 원리를 이해해야한다.
- TS는 타입이 어떻게 추론/검사되는지 원리가 중요하다.
- 타입 시스템의 규칙(타입 계층, 호환성, 좁히기)를 이해해야 새로운 문제에서 응용이 가능하다.

---

## 2. 타입 계층에서 'number'와 `10`(숫자 리터럴 타입)의 관게는?

- A) number 타입은 숫자 리터럴 타입의 하위 타입입니다.
- B) 숫자 리터럴 타입은 number 타입의 상위 타입입니다.
- C) number 타입은 숫자 리터럴 타입의 상위 타입입니다. ✅
- D) 두 타입은 아무 관계가 없습니다.

**해설**

- 숫자 리터럴 타입`10`은 `number` 타입 집합의 부분 집합이다. 포함하는 더 큰 집합인 'number' 타입이 숫자 리터럴 타입의 상위(Super) 타입이다.

- `number` = "모든숫자"
- `10` = "10만 허용"
- 관계는 `10` < `number`(부분집합)
- 10 => number 할당은 안전하다(업캐스팅)
- 반대로 number -> 10은 막힌다.

---

## 3. 타입 호환성에서 보통 안전하게 허용되는 값 할당은?

- A) 상위 타입 값을 하위 타입 변수에 할당
- B) 하위 타입 값을 상위 타입 변수에 할당 ✅
- C) 서로소 유니온 타입 값을 일반 유니온 타입 변수에 할당
- D) any 타입 값을 unknown 타입 변수에 할당

**해설**

- 하위 타입 값을 상위 타입으로 취급하는 것을 업캐스팅이라고 하고, 대부분의 경우 안전하게 허용된다.
- 반대인 다운캐스팅은 일반적으로 허용되지 않는다.

**추가설명**

- **업캐스팅(하위 -> 상위)**: 조건을 더 엄격하게 만족하는 값
  - 10(하위)는 number(상위)로 취급 가능
- **다운캐스팅(상위 -> 하위)**: 상위 타입 값이 하위 타입 조건을 만족한다는 보장이 없어 위험하다.
  - number를 10에 넣으면 10이 아닐수도 있다.

---

## 4. 객체 타입 호환성 판단 기준은?

- A) 두 타입의 이름이 같은지 여부
- B) 객체가 가진 속성과 그 구조 ✅
- C) 타입이 선언된 코드의 순서
- D) type vs interface 키워드

**해설**

- TypeScript는 구조적 타입 시스템을 따르고, 탕입 이름이 아닌 객체가 어떤 속성들을 가지고 있는 지 그 구조를 보고 호환성을 판단한다.

**추가설명**

- TS는 **구조적 타이핑**이라 모양을 본다.
- **필요한 프로퍼티가 있고 타입까지 맞으면 호환**이 가능하다.
- 유연해서 생산성이 좋고, 의미가 다른데 구조가 비슷한 타입이 섞일 수 있다.

---

## 5. 유니온 타입을 조건문 안에서 더 구체적인 타입으로 분석하는 기법은?

- A) 타입 단언 (Type Assertion)
- B) 타입 확장 (Type Widening)
- C) 타입 좁히기 (Type Narrowing) ✅
- D) 초과 속성 확인 (Excess Property Checking)

**해설**

- 조건문을 통해 넓은 타입(유니오너 타입)을 구체적인 타입으로 만드는 과정을 타입 좁히기 또는 타입 가드라고 한다.
- 타입 단언은 개발자가 타입을 확신하고 지정하는 것이다.

**추가 설명**

- 유니온 타입은 둘 중 확정이 안된 상태라 그대로 쓰면 에러가 생긴다.
- `if`, `switch`, `typeof`, `instanceof`, `in`과 같은 조건을통해 **지금 분기에서 어떤 타입인지 확정**시키는게 타입 좁히기다.

- 타입단언은: 이 값은 해당 타입이 맞다라고 강제로 지정하는 것이다(`as Type`)

- 타입확장은: 구체적인 타입(리터럴) 등이 더 넓은 타입으로 자동 변하는 현상이다.

- 초과 속성 확인: **객체 리터럴을 바로 할당/전달**할 때, 타입에 없는 “여분 속성”이 있으면 에러로 잡는 규칙
