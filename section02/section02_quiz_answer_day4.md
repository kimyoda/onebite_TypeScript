📝 이렇게 오늘 배운 내용을 토대로 아래의 4가지 타입에 대해 가볍게 정리해보세요

- Unknown

- Never

- Void

- Any

## TypeScript 특수 타입

- `TypeScript`를 정적 타입을 확인하는 것으로 사이드 프로젝트나 실무 프로젝트를 시작하는 경우가 많아졌다.
- 기본적인 string, number, null, boolean 등 원시타입과 달리 극단적인 상황에서 특수한 타입들을 사용해야 할 경우가 있다.
- 이 글에서는 `unkown`, `any`, `void`, `never` 네 가지 타입을 정리하고, 언제 사용해야하는 정리해봤다.

---

## 특수타입이 필요한 이유

- JavaScript에서 모든 값을 자유롭게 할당할 수 있다(동적 타입).
- 타입스크립트에서는 타입을 명시하는 순간 그 값이 어떤 연산을 지원하는 지 컴파일러가 알아야 한다.
- 라이브러리에서 넘어온 데이터처럼 형태를 모르는 값을 받는 경우, 절대 값이 리턴되지 않는 함수처럼 특수한 경우를 표현해야할 경우가 있다.
- 이땐, 4가지 타입이 유용하게 쓰일 수 있다.

---

### 1. `unknown` - 타입을 모를 때 안전하게 사용

- `unknown`은 타입스크립트에서 타입 안전한 최상위 타입이다. 이 타입은 "아직 타입을 모르는 값"을 표현하고, 어떤 타입의 값이라도 `unknown` 변수에 할당할 수 있다.
- 반대로 `unknown` 값을 다른 타입에 할당할 수 없다.
- 타입 선언이나 타입 좁히기(type narrowing)가 필수다.
- `unknown` 변수는 직접 속성에 접근하거나 함수를 호출할 수 없고, 이를 위해 값의 타입을 검증해야 한다.

```ts
// unknown 타입
let unknownVar: unknown;
// unknown 타입은 any와 달리 할당은 자유롭지만, 사용은 엄격하게 제한됩니다.
unknownVar = "";
unknownVar = 1;
unknownVar = () => {};

// 타입 정제 과정 (Type Narrowing)
// unknown 타입의 값을 사용(할당, 메서드 호출 등)하려면 반드시 타입을 먼저 좁혀야 합니다.
if (typeof unknownVar === "number") {
  // unknownVar의 타입이 이 블록 안에서 number로 정제됨 (narrowing)
  num = unknownVar; // 이제 number 타입 변수에 할당이 허용됩니다.
}
// unknownVar.toFixed(); // 이 상태에서는 오류 발생 (타입 정제 없이 사용 불가)

let value: unknown;

value = 42;
value = "hello";
value = { foo: "bar" };

// 타입을 모르면 바로 속성에 접근하면 안된다
// value.toUpperCase(); 컴파일 에러

// 타입 검사를 좁혀 사용한다.
if (typeof value === "string") {
  // 이 블록에서 value는 string으로 간주된다.
  console.log(value.toUpperCase());
}
```

- `unknown`변수는 타입을 확인한 후 안전하게 사용할 수 있다.
- `typeof`, `instanceof` 또는 사용자 정의 타입 가드 함수를 이용해 타입을 좁힐 수 있다.

### 1.1 장점과 사용상황

- 안전성: `any`와 달리 무조건 타입 검증을 강제하여 예상치 못한 런타임 오류를 줄일 수 있다.
- 유연성: 외부에서 동적으로 들어오는 값이나 JSON 파서 결과처럼 타입을 모르는 값을 표현할 때 유용하다.

단점

- 제한된 사용: 연산을 하기전에 항상 타입 체크를 해야하여 코드가 조금 복잡해질 수 있다.

**사용시기**

- API에서 받은 데이터처럼 형태를 모르는 값을 첫 단계에서 받을 때
- 여러 타입을 받는 함수 매개변수 또는 변수에서 타입 좁히기를 적용하고자 할 때
- 자바스크립트 코드를 타입스크립트로 이전하면서 `any`를 최소화하고 타입 안전을 유지할 때

> `any`와 다르게 타입 안전을 보장하는데 의의가 있다. 모든 값을 받을 수 있으나, 다른 타입으로 사용하려면 검증이 필요하기 때문이다.

---

## 2. `any` - 타입 검사를 건너뛰고 싶을 때

- `any`는 타입스크립트의 탈출 구문이다.
- 변수가 `any`로 선언되면 그 값이 무엇이 들어오든 타입 검사를 하지 않고 통과한다.
- `any` 타입의 값은 어떤 속성을 읽거나 함수처럼 호출해도 컴파일러가 문제를 제기하지 않는다.
- 타입스크립트의 타입 체크를 잠시 비활성화하는 역할을 한다.

```ts
// any 타입
// 특정 변수의 타입을 우리가 확실히 모를 때 사용합니다.
// 런타임 에러가 생길 수 있고, 가능한 한 사용하지 않는 편이 좋습니다.
let anyVar: any = 10;
// anyVar = "hello"; // any 타입이므로 다른 타입의 값을 할당해도 오류가 발생하지 않습니다.
// anyVar.toUIpperCase(); // any 타입이므로 존재하지 않는 메서드를 호출해도 타입 검사 단계에서 오류가 잡히지 않습니다. (런타임 에러 위험)
// anyVar.toFixed(); // any 타입이므로 숫자 타입의 메서드도 오류 없이 호출 가능합니다.
let num: number = 10;
num = anyVar; // any 타입은 모든 타입의 상위 타입처럼 동작하여, any 타입의 값을 다른 타입 변수에 할당하는 것이 허용됩니다.

let anything: any = { x: 0 };
anything.foo(); // 컴파일러는 허용하나, 런타임에 오류가 발생할 수 있다.
anything(); // 함수처럼 호출해도 검사하지 않는다.
anything.bar = 100; // 속성 추가도 가능하다.
anything = "hello";
anything = 42;
const num: number = anything; // 다른 타입에도 할당이 가능하다.
```

- 위 예제처럼 `any`를 사용하면 타입스크립트를 쓰는 의미가 없어진다.
- 런타임 오류를 초래할 가능성이 높아 신중하게 사용해야 한다.

### 2.1 장점과 사용 시점

- 빠른 프로토타이핑: 타입을 정의하기 어렵거나 복잡한 외부 라이브러리를 처음 접할 때 유용하다.
- 점진적 마이그레이션: 기존 자바스크립트 코드를 타입스크립트로 전환하는 과정에서 일부 부분만 우선 작성하고 싶을 때 사용한다.

단점

- 타입 안전성 하락: `any`를 쓰면 타입 검사 기능을 포기하기에, 사용을 최소화 해야한다.
- 오류전파: `any`값이 다른 값과 연산되면 결과도 모두 `any`가 되어 타입 정보가 사라진다.

**활용**

- `noImplicitAny`옵션: 타입스크립트 컴파일러 옵션에서 `noImplicitAny`를 활성화하면 암묵적으로 `any`가 되는 경우를 컴파일 오류로 잡아준다.
- 점진적 마이그레이션: 기존 코드를 옮길 때 일부 타입을 `any`로 두고, 차후에 정확한 타입을 추가하는 방식을 사용한다. 일시적으로 `type T0000 = any`와 같은 별칭을 정의해 수정할 부분을 표시할 수 있다.
- 가능한 `unknown` 사용: 타입을 모를 경우 `unknown`으로 받아서 타입 검증 후 사용하는 것이 더 안전하다.

---

## 3. `void` - 아무것도 돌려주지 않는 타입

- `void`는 반환값이 없음을 나타내는 타입이다.
- 함수의 반환 타입으로 사용되고, 값을 반환하지 않는 함수임을 명시한다.
- `void` 타입의 변수에는 `undefined`나 `null`만 할당할 수 있고, 다른 값은 허용되지 않는다.

```ts
function logMessage(): void {
  console.log("로그만 남기고 아무것도 돌려주지 않아요");
}

let unused: void = undefined; // strictNullChecks 옵션을 끄면 null도 가능
```

### 3.1 규칙

- 함수가 `void` 타입으로 선언되어 있다면 반환값이 없어야 하나, 콜백이나 컨텍스트로 사용될 때는 반환값을 사용하지 않는 구문에서도 일시적으로 다른 값을 반환할 수 있다.
- 타입스크립트 문서에서는 `void` 리턴 타입의 함수는 컨텍스트에서 리턴값을 무시하도록 허용한다고 설명한다.
- 예를들어 `Array.prototype.forEach` 콜백은 `void` 리턴 타입을 요구하나 내부에서 `number`를 반환해도 결과는 무시된다.

```ts
// Void 타입
// 함수가 아무것도 반환하지 않을 때 사용합니다. 함수의 반환 타입으로 주로 사용됩니다.
// 명확성과 타입 안전성을 가질 수 있지만, 제한적인 사용처(주로 함수 반환 타입)를 가집니다.
// void -> 공허 -> 아무것도 없음을 의미하는 타입

function func1(): string {
  return "hello";
}

function func2(): void {
  // 이 함수는 명시적으로 값을 반환하지 않습니다.
  console.log("hello");
  // return undefined; // undefined는 반환해도 void 반환 타입으로 간주됩니다.
}

// let a: void;
// a = undefined; // void 타입 변수에는 undefined만 할당 가능합니다 (strictNullChecks가 false일 경우 null도 가능).

type Void Func = () => void;

const f1: VoidFunc = () => {
  return true; // 컴파일러는 허용하나 반환값은 무시된다.
};

const v1 = f1();
// v1의 타입은 void

// 명시적으로 `void` 타입을 선언한 함수 내에서는 값을 반환할 수 없다
function invalid(): void {
  // return true; // 컴파일 오류
}
```

### 3.2 장점 및 단점

- 장점

  - 명확한 의도: 함수가 아무것도 반환하지 않음을 명시해 가독성을 높인다.

- 단점
  - 제한된 사용: 변수 타입으로 거의 사용할 필요가 없다. `undefined`또는 `null`을 사용하는 편이 명확하다.

---

## 4. `never` - 절대로 발생하지 않은 값

- `never` **타입스크립트 바닥 타입(bottom type)**으로, 값이 절대 존재하지 않는 경우를 나타낸다.
- 무한 루프나 항상 예외를 던지는 함수의 반환 타입이 `never`다.
- `never` 타입은 모든 타입의 하위 타입으로 간주되어 다른 타입에 할당할 수 있지만, 어떠한 타입도 `never`에 할당할 수 없다.

```ts
// never 타입
// 절대로 발생하지 않는 값의 타입입니다.
// never -> 존재하지 않는, 불가능한 타입
// 함수가 예외를 던지거나 무한 루프에 빠져서 정상적으로 종료되지 않을 때 함수의 반환 타입으로 사용됩니다.

function func3(): never {
  // 이 함수는 무한 루프에 빠져서 호출자에게 제어권을 돌려주지 않습니다. (정상 종료 불가)
  while (true) {}
}

function func4(): never {
  // 이 함수는 예외를 던져서 호출자에게 제어권을 돌려주지 않습니다. (정상 종료 불가)
  throw new Error();
}

let a: never;
// a = 10; // never 타입 변수에는 어떤 값도 할당할 수 없습니다 (불가능한 타입).

// 항상 예외를 던지는 함수
function throwError(message: string): never {
  throw new Error(message);
}

// 무한 루프에 빠지는 함수
function loopForever(): never {
  while (true) {}
}

// switch 문에서 모든 케이스를 처리했는지 검증
enum Direction {
  Up,
  Down,
  Left,
  Right,
}

function move(dir: Direction) {
  switch (dir) {
    case Direction.Up:
      return "위로";
    case Direction.Down:
      return "아래로";
    case Direction.Left:
      return "왼쪽";
    case Direction.Right:
      return "오른쪽";
    default:
      const exhaustiveCheck: never = dir; // 새로운 값이 추가되면 컴파일 오류
      return exhaustiveCheck;
  }
}
```

- `never`를 사용하면 열거형의 모든 값을 처리했는 지 컴파일 타임에 검사할 수 있다.
- 예외를 던지는 함수나 무한루프에서 반환값이 존재하지 않음을 명확하게 나타낸다.

### 4.1 장단점

- 장점

  - 코드 의도 표현: 항상 예외를 던지는 함수의 반환 타입을 `never`로 명시하여 사용자와 컴파일러에게 의도를 전달한다.

- 단점
  - 특수한 용도: 일반적인 애플리케이션 로직에서 사용 빈도가 낮고, 주로 유틸리티 타입 또는 컴파일러 검증용으로 쓰인다.

---

## 정리

## 📚 총정리: 4가지 타입 비교

| 타입        | 의미                                 | 주요 특징                                                          | 사용 시점                                       |
| :---------- | :----------------------------------- | :----------------------------------------------------------------- | :---------------------------------------------- |
| **unknown** | 타입을 알 수 없는 값을 안전하게 표현 | 모든 값을 받을 수 있지만, 다른 타입으로 사용하려면 검증 필수       | 동적 데이터, 외부 입력, 타입 검증이 필요한 경우 |
| **any**     | 타입 검사를 건너뛰는 탈출 구문       | 모든 속성 접근과 연산을 허용, 타입 체크가 중단                     | 빠른 프로토타이핑, 점진적 마이그레이션          |
| **void**    | 반환값이 없음을 나타냄               | 함수 반환 타입으로 사용, 변수에는 `undefined`나 `null`만 할당 가능 | 사이드 이펙트만 있는 함수, 콜백                 |
| **never**   | 절대로 발생하지 않는 값              | 모든 타입의 하위 타입이며 예외 또는 무한 루프 함수에서 사용        | `switch` 문 검증, 항상 예외를 던지는 함수       |

### 정리

- `unknown`은 타입을 확인하기 전까지 아무것도 할 수 없어 안전하다. 타입 검증을 통해 값을 좁히는 패턴에 익숙해지면 유용하게 사용할 수 있다.
- `any`는 최후의 수단이다. 정확한 타입을 정의하기 어렵거나 점진적으로 타이핑할때만 사용, 가능한 구체적인 타입으로 교체해야 한다.
- `void`는 함수 반환 타입에서만 사용하길 권장한다. `undefined`나 `null`로 충분한다.
- `never`를 활용해 코드를 안전, switch 문에서 새로운 케이스가 추가될 때 컴파일 오류 경로 누락을 잡아낼 수 있어, 유지보수 과정에서 유용하다.
- TypeScript의 특수 타입을 적절히 사용하면 코드의 명확성과 안전성을 크게 높일 수 있다고 생각한다. 프로젝트 상황에 맞게 각 타입을 적절히 선택해 더 안정적인 코드를 작성하길 우선 나부터 실천하고 싶다.
