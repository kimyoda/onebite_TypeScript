📝 이렇게 오늘 배운 내용을 토대로 아래의 4가지 타입에 대해 가볍게 정리해보세요

- Unknown

- Never

- Void

- Any

## TypeScript 특수 타입

- `TypeScript`를 정적 타입을 확인하는 것으로 사이드 프로젝트나 실무 프로젝트를 시작하는 경우가 많아졌다.
- 기본적인 string, number, null, boolean 등 원시타입과 달리 극단적인 상황에서 특수한 타입들을 사용해야 할 경우가 있다.
- 이 글에서는 `unkown`, `any`, `void`, `never` 네 가지 타입을 정리하고, 언제 사용해야하는 정리해봤다.

---

## 특수타입이 필요한 이유

- JavaScript에서 모든 값을 자유롭게 할당할 수 있다(동적 타입).
- 타입스크립트에서는 타입을 명시하는 순간 그 값이 어떤 연산을 지원하는 지 컴파일러가 알아야 한다.
- 라이브러리에서 넘오언 데이터처럼 형태를 모르는 값을 받는 경우, 절대 값이 리턴되지 않는 함수처럼 특수한 경우를 표현해야할 경우가 있다.
- 이땐, 4가지 타입이 유용하게 쓰일 수 있다.

---

### 1. `unknown` - 타입을 모를 때 안전하게 사용

- `unknown`은 타입스크립트에서 타입 안전한 최상위 타입이다. 이 타입은 "아직 타입을 모르는 값"을 표현하고, 어떤 타입의 값이라도 `unknown` 변수에 할당할 수 있다.
- 반대로 `unknown` 값을 다른 타입에 할당할 수 없다.
- 타입 선언이나 타입 좁히기(type narrowing)가 필수다.
- `unknown` 변수는 직접 속성에 접근하거나 함수를 호출할 수 없고, 이를 위해 값의 타입을 검증해야 한다.

```ts
let value: unknown;

value = 42;
value = "hello";
value = { foo: "bar" };

// 타입을 모르면 바로 속성에 접근하면 안된다
// value.toUpperCase(); 컴파일 에러

// 타입 검사를 좁혀 사용한다.
if (typeof value === "string") {
  // 이 블록에서 value는 string으로 간주된다.
  console.log(value.toUpperCase());
}
```

- `unknown`변수는 타입을 확인한 후 안전하게 사용할 수 있다.
- `typeof`, `instanceof` 또는 사용자 정의 타입 가드 함수를 이용해 타입을 좁힐 수 있다.

### 1.1 장점과 사용상호아

- 안전성: `any`와 달리 무조건 타입 검증을 강제하여 예상치 못한 런타임 오류를 줄일 수 있다.
- 유연성: 외부에서 동적으로 들어오는 값이나 JSON 파서 결과처럼 타입을 모르는 값을 표현할 때 유용하다.

단점

- 제한된 사용: 연산ㅇ르 하기전에 항상 타입 체크를 해야하여 코드가 조금 복잡해질 수 있다.

**사용시기**

- API에서 받은 데이터처럼 형태를 모르는 값을 첫 단계에서 받을 때
- 여러 타입을 받는 함수 매개변수 또는 변수에서 타입 좁히기를 적용하고자 할 때
- 자바스크립트 코드를 타입스크립트로 이전하면서 `any`를 최소화하고 타입 아전을 유지할 때

> `any`와 다르게 타입 아전을 보장하는데 의의가 있다. 모든 값을 받을 수 있으나, 다른 타입으로 사용하려면 검증이 필요하기 때문이다.

---

## 2. `any` - 타입 검사를 건너뛰고 싶을 때

- `any`는 타입스크립트의 탈출 구문이다.
- 변수가 `any`로 선언되면 그 값이 무엇이 들어오든 타입 검사를 하지 않고 통과한다.
- `any` 타입의 값은 어떤 속성을 읽거나 함수처럼 호출해도 컴파일러가 문제를 제기하지 않는다.
- 타입스크립트의 타입 체크를 잠시 비활성화하는 역할을 한다.

```ts
let anything: any = { x: 0 };
anything.foo(); // 컴파일러는 허용하나, 런타임에 오류 가능성이 있다.
anything(); // 함수처럼 호출해도 검사하지 않는다.
anything.bar = 100; // 속성 추가도 가능하다.
anything = "hello";
anything = 42;
const num: number = anything; // 다른 타입에도 할당이 가능하다.
```

- 위 예제처럼 `any`를 사용하면 타입스크립트를 쓰는 의미가 없어진다.
- 런타임 오류를 초래할 가능성이 높아 신중하게 사용해야 한다.

### 2.1 장점과 사용 시점

- 빠른 프로토타이핑: 타입을 정의하기 어렵거나 복잡한 외부 라이브러리를 처음 접할 때 유용하다.
- 점진적 마이그레이션: 기존 자바스크립트 코드를 타입스크립트로 전환하는 과정에서 일부 부분만 우선 작성하고 싶을 때 사용한다.

단점

- 타입 안전성 하락: `any`를 쓰면 타입 검사 기능을 포기하기에, 사용을 최소화 해야한다.
- 오류전파: `any`값이 다른 값과 연산되면 결과도 모두 `any`가 되어 타입 정보가 사라진다.

**활용**

- `noImplicitAny`옵션: 타입스크립트 컴파일러 옵션에서 `noImplicitAny`를 홞성화하면 암묵적으로 `any`가 되는 경우를 컴파일 오류로 잡아준다.
- 점진적 마이그레이션: 기존 코드를 옮길 때 일부 타입을 `any`로 두고, 차후에 정확한 타입을 추가하는 방식을 사용한다. 일시적으로 `type T0000 = any`와 같은 별칭을 정의해 수정할 부분을 표시할 수 있다.
- 가능한 `unknown` 사용: 타입을 모를 경우 `unknown`으로 받아서 타입 검증 후 사용하는 것이 더 안전하다.
