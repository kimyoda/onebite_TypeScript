# TypeScript 퀴즈

---

## 1. TypeScript 코드는 브라우저 환경에서 어떻게 실행될까?

-> 트랜스파일(Transpile)

- 브라우저는 **TypeScript를 직접 실횅할 수 없고**, JavaScript만 이해한다.
- TypeScript 파일은 먼저 **JS 코드로 변환(트랜스파일)**되어야 실행된다.

- TypeScript 트랜스파일 과정 특징:

1. 타입 검사 & 문법 오류를 컴파일 단계에서 먼저 잡아준다
2. 실행 시점에 순수 자바스크립트만 동작한다.

> 💡 TypeScript는 "런타임에서는 존재하지 않는 언어"라고 이해하면 쉽다.

---

## 2. TypeScript에서 '튜플(Tuple)'은 일반 배열과 어떻게 다른가?

-> 요소의 개수와 자료형 모두를 제한한다.

- 튜플은 **배열의 확장된 형태**지만 아래 두 가지가 고정된다.

1. **요소 수(Length)**.
2. **각 요소의 타입(Type)**.

- 즉, 배열은 유동적이고 자유로운 반면, 튜플은 "몇 번째 자리에 어떤 타입이 와야 하는지"까지 명확하게 정의한다.

```ts
type Point = [number, number];
const p: Point = [10, 20];
const p2: Point = [10, "20"]; // 타입 불일치
```

---

## 3. 이름이 부여된 상수 값 집합을 정의할 수 있는 타입은?

-> Enum

- Enum은 서로 연관된 상수(Constant)들을 하나의 그룹으로 묶고, 각 값에 의미 있는 이름을 부여하는 구조다.

- 장점:
  - 상수 관리 용이
  - 코드 가독성 향상
  - 의미 기반으로 비교가 가능

```ts
enum Role {
  Admin = "ADMIN",
  User = "USER",
}
```

> 최근 실무에서는 `union literal`로 대체하는 경우도 있다.
> 예 `type Role = "ADMIN" | "USER"`;

---

## 4. `unknown`타입은 `any`타입과 비교하여 무엇이 다른가?

-> `unknown`은 타입 검사를 강제한다.

- 두 타입 모두 "어던 타입이든 담을 수 있다"는 공통점이 있으나, 차이점이 있다.
  - `any`: 제약이 없다 -> 타입 안전성이 완전히 사라진다.
  - `unknown`: 사용하기 전에 반드시 타입 좁히기가 필요하다.

```ts
let a: unknown = "hello";

a.toUpperCase(); // 타입 체크 전에는 메서드 접근이 불가

if (typeof a === "string") {
  a.toUpperCase(); // 타입 좁히기 후에는 가능
}
```

> 💡 안전성과 유연성을 동시에 챙기고 싶을 때 unknown을 사용하는 것이 좋다.

---

## 5. TypeScript 객체 타입 호환성을 결정하는 메커니즘은?

-> 구조적 타입 검사(Structural Typing)

- TS는 이름 기반이 아니라 "객체 구조" 기반으로 타입을 판단한다.
- 인터페이스 이름이 같지 않아도 "속성 형태가 일치"하면 같은 타입으로 간주한다.

```ts
interface User {
  name: string;
}

const person = { name: "Yohan", age: 34 };

const u: User = person; // 구조가 호환되므로 가능
```

> “덕 타이핑(duck typing)과 유사하다”고도 표현

---

- 개념 핵심 정리
  | 번호 | 개념 | 핵심 정리 |
  |------|------------------|------------------------------------------------------|
  | 1 | TS 실행 방식 | 트랜스파일 후 JS로 변환되어 브라우저에서 실행됨 |
  | 2 | 튜플 | 요소 개수 + 각 위치의 타입까지 고정 |
  | 3 | Enum | 이름 있는 상수 집합 정의 |
  | 4 | unknown | any보다 안전, 사용 전 타입 좁히기 필수 |
  | 5 | 구조적 타이핑 | 객체 이름이 아닌 "구조"로 타입 호환 판단 |
